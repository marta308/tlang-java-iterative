import java.util.regex.*;

aspect NameAnalysis {
	
	
	  syn String Declaration.qname(){ 
		  String parentName = parentName();
		  return "" + ((parentName != null)? parentName + "." : "") + getName();
	  }
	  
	  inh String Declaration.parentName();
	  eq CompilationUnit.getClassDeclaration(int i).parentName() = null;
	  eq ClassDeclaration.getClassBody(int i).parentName(){
		  String parentName = parentName();
		  return "" + ((parentName != null)? parentName + "." : "") + getName();
	  }
	  eq MethodDeclaration.getParameters(int i).parentName(){
		  String parentName = parentName();
		  return "" + ((parentName != null)? parentName + "." : "") + getName();
	  }
	  eq MethodDeclaration.getMethodBody(int i).parentName(){ 
		  String parentName = parentName();
		  return "" + ((parentName != null)? parentName + "." : "") + getName();
	  }
	
	  /*syn java.util.List<Declaration> ASTNode.lookup(String label){
		   if(this instanceof CompilationUnit)
			   return ((CompilationUnit)this).lookup(label);
		   else if(this instanceof ClassDeclaration)
			   return ((ClassDeclaration)this).lookup(label);
		   else if(this instanceof MethodDeclaration)
			   return ((MethodDeclaration)this).lookup(label);
		   else return null;
	}*/
	  
	syn Declaration Root.lookup(String declName){
  		//java.util.List<Declaration> match = new java.util.LinkedList<Declaration>();
		Declaration match = null;
  		for(CompilationUnit cu : getCompilationUnitsList()){
  			match = cu.lookup(declName);
  			if(match != null)
  				return match;
  		}
  		return null;
  	}
	
  
	syn Declaration CompilationUnit.lookup(String label){
		//java.util.List<Declaration> match = new java.util.LinkedList<Declaration>();
		Declaration match = null;
		for (Declaration d : getClassDeclarationList()){
			match = d.lookup(Declaration.split(label));
			if(match != null)
  				return match;
		}
		return null;
	}
	
	syn Declaration Declaration.lookup(String[] parts) = null;
	
	eq ClassDeclaration.lookup(String[] parts){
		//java.util.List<Declaration> match = new java.util.LinkedList<Declaration>();
		Declaration match = null;
		if(parts == null)
			return null;
		
		Declaration localMatch = localLookup(parts[0]);
		if(localMatch != null && parts[1].equals(""))
			return localMatch;
		
		if(localMatch != null  && !parts[1].equals("")){
			String[] nextParts = split(parts[1]);
			for(Declaration d : getClassBodyList()){
				match = d.lookup(nextParts);
				if(match != null)
	  				return match;
			}
		}
		
		if(parts[2] != null){
			String[] nextParts = split(parts[2]);
			for(Declaration d : getClassBodyList()){
				match = d.lookup(nextParts);
				if(match != null)
	  				return match;
			}
		}
		return null;
	}
	
	eq MethodDeclaration.lookup(String[] parts){
		//java.util.List<Declaration> match = new java.util.LinkedList<Declaration>();
		Declaration match = null;
		if(parts == null)
			return null;
		
		Declaration localMatch = localLookup(parts[0]);
		if(localMatch != null && parts[1].equals(""))
			return localMatch;
		
		
		if(localMatch != null && !parts[1].equals("")){
			String[] nextParts = split(parts[1]);
			for(Declaration d : getParametersList()){
				match = d.lookup(nextParts);
				if(match != null)
	  				return match;				
			}
			for(Declaration d : getMethodBodyList()){
				match = d.lookup(nextParts);
				if(match != null)
	  				return match;
			}
		}
		
		if(parts[2] != null){
			String[] nextParts = split(parts[2]);
			for(Declaration d : getParametersList()){
				match = d.lookup(nextParts);
				if(match != null)
	  				return match;
			}
			for(Declaration d : getMethodBodyList()){
				match = d.lookup(nextParts);
				if(match != null)
	  				return match;
			}
		}
   		return null;
	}
	
	eq FieldOrHookDeclaration.lookup(String[] parts){
		//java.util.List<Declaration> match = new java.util.LinkedList<Declaration>();
		Declaration match = null;
		if(parts[1].equals(""))
			match = localLookup(parts[0]);
		return match;
		
	}
	
	syn Declaration Declaration.localLookup(String label){
		//java.util.List<Declaration> match = new java.util.LinkedList<Declaration>();
		if(label.equals(this.getName()) || label.equals("*"))
			return this;
		return null;
	}
   
   //wildcards-not-supported-local lookup
	
   syn Declaration ASTNode.lookupNOWC(String label){
	   if(this instanceof CompilationUnit)
		   return ((CompilationUnit)this).lookupNOWC(label);
	   else if(this instanceof ClassDeclaration)
		   return ((ClassDeclaration)this).lookupNOWC(label);
	   else if(this instanceof MethodDeclaration)
		   return ((MethodDeclaration)this).lookupNOWC(label);
	   else return null;
   }
   
   syn Declaration CompilationUnit.lookupNOWC(String label){
	   for (Declaration d : getClassDeclarationList()){
		   if(label.equals(d.getName()))
			   return d;
	   }
	   return null;
   }
   
   syn Declaration ClassDeclaration.lookupNOWC(String label){
	   for(Declaration d : getClassBodyList()){
		   if(label.equals(d.getName()))
			   return d;
	   }
	   return null;
   }
   
   syn Declaration MethodDeclaration.lookupNOWC(String label){
	   for(Declaration d : getParametersList()){
		   if(label.equals(d.getName()))
			   return d;
	   }
	   for(Declaration d : getMethodBodyList()){
		   if(label.equals(d.getName()))
			   return d;
	   }
	   return null;
   }	
   
	//parts[0] - for local lookup, part[1] - for further lookup,
	//parts[2] - for further lookup in case of **/*n wildcards
	public static String[] Declaration.split(String label){
		if(label.equals(""))
			return null;
		String[] parts = new String[3];
		int dotindex = label.indexOf('.');
		if(dotindex == -1){
			parts[0] = label;
			parts[1] = "";
			return parts;
		}
		parts[0] = label.substring(0, dotindex);
		parts[1] = label.substring(dotindex+1);
		if(!parts[0].contains("*") || parts[0].equals("*")){  //name or simple wildcard
			parts[2] = null;
			return parts;
		}
		String part0 = parts[0];				//** or *n wildcard
		String part1 = parts[1];
		int dotindex2 = part1.indexOf('.');		
		if(dotindex2 == -1){
			parts[0] = part1;
			parts[1] = "";
		}
		else{
			parts[0] = part1.substring(0, dotindex2);
			parts[1] = part1.substring(dotindex2+1);
		}
		if(part0.equals("**")){			//** wildcard
			parts[2] = label;
			return parts;
		}
		int num = Integer.parseInt(part0.substring(1));		//*n wildcard
		num--;
		if(num > 0)
			parts[2] = "*" + num + "." + part1;
		else
			parts[2] = part1;
		return parts;		
	}
	/*
   //label1 - searched name, label2 - declarations' qname
   public static boolean Declaration.match(String label1, String label2){
	   if(!label1.contains("*"))
		   return label1.equals(label2);
	   
	   String [] parts1 = label1.split("\\.");
	   String [] parts2 = label2.split("\\.");
	   int index1 = 0;
	   int index2 = 0;
	   for(;index1 < parts1.length && index2 < parts2.length; index1++){
		   if (!parts1[index1].contains("*")){		//part without wildcards
			   if(parts1[index1].equals(parts2[index2]))
				   index2++;
			   else return false;
		   }
		   else if(parts1[index1].equals("*"))		//simple wildcard  - (*)
			   index2++;
		   else if(parts1[index1].matches("\\*[0-9]+")){		//[0, n] wildcard - (*n)
			   int limit = Integer.parseInt(parts1[index1].substring(1));
			   if(index1 != parts1.length - 1){
				   String nextPart = parts1[index1+1];
				   int j = 0;
				   for(; j <= limit && !nextPart.equals(parts2[index2]); j++){
					   index2++;
					   if(index2 >= parts2.length)
						   return false;
				   }
				   if(j > limit)
					   return false;
			   }
			   else 
				   return index1 + limit >= parts2.length;
		   }
		   else if(parts1[index1].equals("**")){				//[0, inf) wildcard - (**)
			   if(index1 != parts1.length - 1){
				   String nextPart = parts1[index1+1];
				   while(!nextPart.equals(parts2[index2])){
					   index2++;
					   if(index2 >= parts2.length)
						   return false;
				   }
			   }
			   else return true;
		   }		   
	   }
	   if(index1 == parts1.length && index2 == parts2.length ||
			   index1 + 1 == parts1.length && 
			   (parts1[index1].equals("**") || parts1[index1].matches("\\*[0-9]+")))
		   return true;
	   else return false;
   }
   */
      
  
}
